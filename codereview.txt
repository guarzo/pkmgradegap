codereview.txt

What’s strong

Clear seams: internal/analysis, cache, cards (PokéTCG), prices (PriceCharting), ebay, monitoring (history/snapshot/alerts), ratelimit, volatility, population. Good boundaries and tests in most packages.

Tests exist for the important bits (analysis scoring, cache, ebay mocks, monitoring timing/optimizer/snapshot, ratelimit). Nice.

Gaps & correctness nits (fix first)

Outlier handling (data sanity)

Your sample caches include wild values (e.g., 69420.xx, 5000.32) that will break scoring/sorting and cause bogus “opportunities.” Add a single “sanitizer” in analysis:

Drop TCGPlayer/Cardmarket points above, say, p99 per rarity or cap at a reasonable max (e.g., $500 for commons, $1,500 for rares, $5k for SIR/HR).

Require min sales density (e.g., only use market if avg7/avg30 exists or a recent updatedAt).

If raw < $0.05, treat as noise unless --allow-pennies.

Add one unit test with a row containing 69420.xx to assert it’s discarded.

CSV safety & stability

Prevent CSV formula injection if you ever open in Excel/Sheets: if any cell starts with =, +, -, or @, prefix with '.

Keep column order fixed across modes; if feature flags add columns, append them only at the end. Add a header-order test.

Locking in cache

Ensure cache.Store.Put does not call a Save() that also tries to lock s.mu (double-lock → deadlock). Pattern:

func (s *Store) putLocked(...) { ... } // no locking
func (s *Store) Put(...) { s.mu.Lock(); defer s.mu.Unlock(); s.putLocked(...); return s.saveLocked() }


And keep saveLocked() unexported and not locking.

Context & HTTP reuse

Plumb context.Context from the CLI into providers; add timeouts per request and a shared *http.Client{Timeout: …} per host.

Use a single Transport (keep-alive) and set a concise User-Agent (helpful for vendors/rate-limits).

Rate-limit & backoff

You have a ratelimit package—great. Make sure:

Rate buckets are per host (pokemontcg.io, prices..., svcs.ebay.com).

On 429/5xx, jittered backoff (cap at e.g. 4–8s) + one retry max.

Tests assert the limiter blocks bursts deterministically.

Release date parsing

Your plan relies on < N years filters. Add tolerant parsing (2006/1/2, 2006-01-02, missing day→first of month) and tests for each layout plus future dates (return 0).

Ebay listing hygiene

Strengthen “raw only” filter: drop titles containing psa, bgs, cgc, slab, graded, sgc, beckett (case-insensitive).

Add a max shipping filter when you parse price (if available), else note “price excl. shipping.”

Timebox to <= 2s per query, hard cap results (you already do).

Robust price selection

Prefer tcgplayer.prices.*.market when present; fall back to mid only if market missing/outlier. For Cardmarket, prefer trendPrice over point estimates.

If both vendors available, take median of available vendor values after sanitation. Simple, explainable.

Scoring guardrails (defaults)

Skip rows where PSA10 <= Raw or where PSA9 / PSA10 >= 0.8 unless --allow-thin-premium.

Add --min-raw-usd (default $0.50) to avoid penny noise.

Snapshot integrity

When writing snapshots/history, include run parameters (grading cost, shipping, fee %, min-delta, max-age) in a small JSON sidecar or a comment row in CSV so future comparisons are apples-to-apples.

Plan coverage check (what you aimed for vs what’s in code)

Age filter / modern focus: Present in analysis flow; ensure it’s enforced early to avoid wasted lookups, and that set ReleaseDate is coming from PokéTCG. Add a single unit test with an “old” set to confirm exclusion.

Japanese overweighting: Present in scoring; good that it’s a multiplier and optional. Default it to 1.0 and expose a flag; document in README.

History + snapshots: You have internal/monitoring/{history,snapshot}.go with tests—great. Append exactly one header; test that appends don’t duplicate.

Volatility / population: Packages exist with tests. Keep them off by default and append their columns at the end when enabled so CSV schema stays stable.

Ebay optional path: Exists with mocks/tests. Keep it opt-in, rate-limited, and time-boxed.

Quick wins (1–2 hour changes)

One “sanity” helper in analysis that:

clamps impossible values,

chooses the vendor/field,

returns (rawUSD, reason string) to include in --why output.

cmd ergonomics:

--why flag prints a short per-row rationale: delta=$x, ninePct=yy%, vendor=tcg.market, notes=clamped.

--min-raw-usd default 0.50; --min-delta-usd default 25.

Exit early with a human message if set age > --max-age-years.

Docs: A single copy-paste command in README.md that runs the “rank” analysis with sensible defaults, and a table describing each column.

Test holes to fill (tiny, high value)

Outlier drop: a test that feeds a 69420.77 market price and asserts it’s ignored.

CSV header order: assert exact header sequence once (golden).

Sanity vendor choice: table-driven test: (tcg.market only), (tcg.market missing → tcg.mid), (both present but one outlier → median), (no vendor → skip).

Limiter: assert N+1 requests in window are delayed; use a fake clock if your limiter supports it.

History writer: appends only once header; subsequent runs add rows only.

Idiomatic Go cleanups (non-blocking)

Constructors return concrete types; define tiny consumer-side interfaces only in the consumer package (you already follow this mostly—keep it up).

Group HTTP clients by host in a small internal/httpx subpackage; export ClientFor(host string) *http.Client.

Return errors.Is(ctx.Err(), context.DeadlineExceeded) checks where appropriate; wrap vendor errors with %w and short context (“poketcg list sets: %w”).

Stretch (when you want)

Quantile-based outliering: compute per-rarity quantiles from the set to learn caps automatically (no magic numbers); cache for run.

Pop/Scarcity overlay: when enabled, multiply score by a smooth factor like 1 + log1p( (psa10 / 50) ^ -1 ) with clamping to [0.9, 1.2]; keep effect tiny.

If you want, I can draft the tiny analysis/sanitize.go + a table-driven test and a one-function CSV sanitizer next. 

repomix-output

Sources
You said:
yes, please do those things
ChatGPT said:
Thought for 22s

Awesome—here are the drop-in files you asked for: a tiny, opinionated raw-price “sanitizer + chooser” for analysis, plus a one-function CSV cell sanitizer. I included full table-driven tests.

internal/analysis/sanitize.go
package analysis

import (
	"math"
	"sort"
	"strings"

	"github.com/guarzo/pkmgradegap/internal/model"
)

// SanitizeOptions controls raw-price selection and outlier handling.
type SanitizeOptions struct {
	// Prices below this are treated as noise unless AllowPennies is true.
	MinRawUSD    float64
	AllowPennies bool

	// (Optional) rarity hint from the card record. Used only to pick a soft cap.
	// Expected examples: "Common", "Uncommon", "Rare", "Ultra Rare", "Secret Rare",
	// "Illustration Rare", "Special Illustration Rare", etc.
	Rarity string
}

// ChooseRawUSD inspects vendor fields on a card (TCGplayer, Cardmarket, etc.),
// applies light outlier handling, and returns a single raw USD price,
// with its source label and a short note explaining any sanitation.
//
// It is intentionally boring and explainable:
//   1) Gather a few candidate prices (TCG: market,mid; Cardmarket: trend,avg30)
//   2) Drop NaN/Inf/<=0 and very small values (unless AllowPennies)
//   3) Clamp obvious outliers with a soft cap chosen by rarity bucket
//   4) Take the median of the remaining candidates
//
// If nothing reasonable remains, (0,"","") is returned so callers can skip the row.
func ChooseRawUSD(card model.Card, opt SanitizeOptions) (price float64, source, note string) {
	candidates := make([]candidate, 0, 4)

	// ---- Gather from TCGplayer ----
	if card.TCGPlayer != nil && card.TCGPlayer.Prices != nil {
		for code, p := range card.TCGPlayer.Prices {
			// Try market, then mid, then low as weak fallback.
			if p.Market != nil && isFinite(*p.Market) {
				candidates = append(candidates, candidate{
					Val:    *p.Market,
					Source: "tcgplayer.market(" + code + ")",
				})
			}
			if p.Mid != nil && isFinite(*p.Mid) {
				candidates = append(candidates, candidate{
					Val:    *p.Mid,
					Source: "tcgplayer.mid(" + code + ")",
				})
			}
			if p.Low != nil && isFinite(*p.Low) {
				candidates = append(candidates, candidate{
					Val:    *p.Low,
					Source: "tcgplayer.low(" + code + ")",
				})
			}
			if p.DirectLow != nil && isFinite(*p.DirectLow) {
				candidates = append(candidates, candidate{
					Val:    *p.DirectLow,
					Source: "tcgplayer.directLow(" + code + ")",
				})
			}
		}
	}

	// ---- Gather from Cardmarket ----
	if card.Cardmarket != nil {
		pr := card.Cardmarket.Prices
		if isPtrFinite(pr.TrendPrice) {
			candidates = append(candidates, candidate{Val: *pr.TrendPrice, Source: "cardmarket.trend"})
		}
		if isPtrFinite(pr.Avg30) {
			candidates = append(candidates, candidate{Val: *pr.Avg30, Source: "cardmarket.avg30"})
		}
		if isPtrFinite(pr.AverageSellPrice) {
			candidates = append(candidates, candidate{Val: *pr.AverageSellPrice, Source: "cardmarket.avg"})
		}
		// Reverse-holo trends exist but usually don't represent base raw supply;
		// only include if nothing else appears (we'll add below if needed).
	}

	// If nothing gathered, try reverse-holo as last resort (rare).
	if len(candidates) == 0 && card.Cardmarket != nil {
		pr := card.Cardmarket.Prices
		if isPtrFinite(pr.ReverseHoloTrend) {
			candidates = append(candidates, candidate{Val: *pr.ReverseHoloTrend, Source: "cardmarket.reverseHoloTrend"})
		}
		if isPtrFinite(pr.ReverseHoloAvg30) {
			candidates = append(candidates, candidate{Val: *pr.ReverseHoloAvg30, Source: "cardmarket.reverseHoloAvg30"})
		}
	}

	if len(candidates) == 0 {
		return 0, "", ""
	}

	// ---- Filter tiny values (pennies) and non-positive ----
	minRaw := opt.MinRawUSD
	if minRaw <= 0 {
		minRaw = 0.50 // safe default
	}
	filtered := candidates[:0]
	for _, c := range candidates {
		if !opt.AllowPennies && c.Val > 0 && c.Val < minRaw {
			continue
		}
		if c.Val > 0 {
			filtered = append(filtered, c)
		}
	}
	candidates = filtered
	if len(candidates) == 0 {
		return 0, "", ""
	}

	// ---- Clamp obvious outliers using a soft cap by rarity ----
	capUSD := rarityCapUSD(opt.Rarity)
	clampedAny := false
	for i := range candidates {
		if candidates[i].Val > capUSD {
			candidates[i].Val = capUSD
			clampedAny = true
		}
	}

	// ---- Median for robustness ----
	sort.Slice(candidates, func(i, j int) bool { return candidates[i].Val < candidates[j].Val })
	val := medianOf(candidates)

	// Prefer the source closest to the chosen median (for explainability).
	chosen := closestTo(val, candidates)

	var noteParts []string
	if clampedAny {
		noteParts = append(noteParts, "clamped")
	}
	if !opt.AllowPennies && minRaw > 0 {
		noteParts = append(noteParts, "min="+trimDollar(minRaw))
	}
	return val, chosen.Source, strings.Join(noteParts, ",")
}

// ---- internal helpers ----

type candidate struct {
	Val    float64
	Source string
}

func isFinite(v float64) bool { return !math.IsNaN(v) && !math.IsInf(v, 0) }
func isPtrFinite(p *float64) bool {
	return p != nil && isFinite(*p)
}

func rarityCapUSD(rarity string) float64 {
	r := strings.ToLower(strings.TrimSpace(rarity))
	switch {
	case strings.Contains(r, "special illustration"):
		return 5000
	case strings.Contains(r, "illustration"):
		return 4000
	case strings.Contains(r, "secret") || strings.Contains(r, "hyper"):
		return 3500
	case strings.Contains(r, "ultra") || strings.Contains(r, "trainer gallery"):
		return 2000
	case strings.Contains(r, "rare"):
		return 1500
	default:
		// commons/uncommons or unknown
		return 500
	}
}

func medianOf(cc []candidate) float64 {
	n := len(cc)
	if n == 0 {
		return 0
	}
	if n%2 == 1 {
		return cc[n/2].Val
	}
	return 0.5 * (cc[n/2-1].Val + cc[n/2].Val)
}

func closestTo(target float64, cc []candidate) candidate {
	best := cc[0]
	bestd := math.Abs(cc[0].Val - target)
	for _, c := range cc[1:] {
		if d := math.Abs(c.Val - target); d < bestd {
			best, bestd = c, d
		}
	}
	return best
}

func trimDollar(v float64) string {
	// simple, avoids fmt allocations in the hot path
	cents := int(math.Round(v * 100))
	d := cents / 100
	c := cents % 100
	return "$" + itoa(d) + "." + twoDigits(c)
}

func itoa(n int) string {
	if n == 0 {
		return "0"
	}
	var s [16]byte
	i := len(s)
	neg := n < 0
	if neg {
		n = -n
	}
	for n > 0 {
		i--
		s[i] = byte('0' + (n % 10))
		n /= 10
	}
	if neg {
		i--
		s[i] = '-'
	}
	return string(s[i:])
}

func twoDigits(n int) string {
	if n < 10 {
		return "0" + string('0'+byte(n))
	}
	return itoa(n)
}

internal/analysis/sanitize_test.go
package analysis

import (
	"math"
	"testing"

	"github.com/guarzo/pkmgradegap/internal/model"
)

func ptr(v float64) *float64 { return &v }

func TestChooseRawUSD_BasicMedianAcrossVendors(t *testing.T) {
	card := model.Card{
		Rarity: "Rare",
		TCGPlayer: &model.TCGPlayerBlock{
			Prices: map[string]struct {
				Low       *float64 `json:"low,omitempty"`
				Mid       *float64 `json:"mid,omitempty"`
				High      *float64 `json:"high,omitempty"`
				Market    *float64 `json:"market,omitempty"`
				DirectLow *float64 `json:"directLow,omitempty"`
			}{
				"normal": {Mid: ptr(4.00)}, // market missing -> mid fallback
			},
		},
		Cardmarket: &model.CardmarketBlock{
			Prices: struct {
				AverageSellPrice *float64 `json:"averageSellPrice,omitempty"`
				TrendPrice       *float64 `json:"trendPrice,omitempty"`
				ReverseHoloTrend *float64 `json:"reverseHoloTrend,omitempty"`
				Avg7             *float64 `json:"avg7,omitempty"`
				Avg30            *float64 `json:"avg30,omitempty"`
				ReverseHoloAvg7  *float64 `json:"reverseHoloAvg7,omitempty"`
				ReverseHoloAvg30 *float64 `json:"reverseHoloAvg30,omitempty"`
			}{
				TrendPrice: ptr(3.00),
				Avg30:      ptr(3.20),
			},
		},
	}

	got, src, note := ChooseRawUSD(card, SanitizeOptions{
		MinRawUSD:    0.50,
		AllowPennies: false,
		Rarity:       card.Rarity,
	})
	// candidates: 4.00 (tcg.mid), 3.00 (cm.trend), 3.20 (cm.avg30)
	// sorted: [3.00, 3.20, 4.00] => median = 3.20
	if math.Abs(got-3.20) > 1e-6 {
		t.Fatalf("got %.2f, want 3.20 (median)", got)
	}
	if src == "" {
		t.Fatalf("expected a source label")
	}
	if note != "min=$0.50" && note != "" { // min note may appear depending on code path
		t.Fatalf("unexpected note: %q", note)
	}
}

func TestChooseRawUSD_ClampsObviousOutlier(t *testing.T) {
	card := model.Card{
		Rarity: "Common",
		TCGPlayer: &model.TCGPlayerBlock{
			Prices: map[string]struct {
				Low       *float64 `json:"low,omitempty"`
				Mid       *float64 `json:"mid,omitempty"`
				High      *float64 `json:"high,omitempty"`
				Market    *float64 `json:"market,omitempty"`
				DirectLow *float64 `json:"directLow,omitempty"`
			}{
				"normal": {Market: ptr(69420.77)}, // silly outlier
			},
		},
	}
	got, _, note := ChooseRawUSD(card, SanitizeOptions{
		MinRawUSD:    0.50,
		AllowPennies: false,
		Rarity:       "Common",
	})
	// common cap is $500 per rarityCapUSD
	if got != 500.00 {
		t.Fatalf("got %.2f, want 500.00 (clamped cap for common)", got)
	}
	if note == "" || note[:7] != "clamped" {
		t.Fatalf("expected note to mention clamped, got %q", note)
	}
}

func TestChooseRawUSD_DropsPenniesByDefault(t *testing.T) {
	card := model.Card{
		Rarity: "Rare",
		TCGPlayer: &model.TCGPlayerBlock{
			Prices: map[string]struct {
				Low       *float64 `json:"low,omitempty"`
				Mid       *float64 `json:"mid,omitempty"`
				High      *float64 `json:"high,omitempty"`
				Market    *float64 `json:"market,omitempty"`
				DirectLow *float64 `json:"directLow,omitempty"`
			}{
				"normal": {Market: ptr(0.03)},
			},
		},
	}
	got, src, _ := ChooseRawUSD(card, SanitizeOptions{
		MinRawUSD:    0.50,
		AllowPennies: false,
		Rarity:       "Rare",
	})
	if got != 0 || src != "" {
		t.Fatalf("expected drop -> 0 price and empty source, got %.2f, %q", got, src)
	}

	// Allow pennies -> keep it
	got2, src2, _ := ChooseRawUSD(card, SanitizeOptions{
		MinRawUSD:    0.50,
		AllowPennies: true,
		Rarity:       "Rare",
	})
	if got2 != 0.03 || src2 == "" {
		t.Fatalf("expected keep pennies -> 0.03 with source, got %.2f, %q", got2, src2)
	}
}

internal/report/csvsafe.go
package report

// SanitizeCell shields against CSV/Excel formula injection by prefixing a single
// quote when a cell begins with a risky character. This keeps downstream tools
// happy without changing semantics in plain CSV readers.
//
// It’s intentionally minimal: if the first rune is one of = + - @ or a tab,
// we prefix a single quote. Otherwise, return unchanged.
//
// Usage: call before writing any untrusted text cells.
func SanitizeCell(s string) string {
	if s == "" {
		return s
	}
	switch s[0] {
	case '=', '+', '-', '@', '\t':
		return "'" + s
	default:
		return s
	}
}

internal/report/csvsafe_test.go
package report

import "testing"

func TestSanitizeCell(t *testing.T) {
	cases := []struct {
		in   string
		want string
	}{
		{"=HYPERLINK(\"http://evil\")", "'=HYPERLINK(\"http://evil\")"},
		{"+SUM(A1:A2)", "'+SUM(A1:A2)"},
		{"-1+1", "'-1+1"},
		{"@A1", "'@A1"},
		{"\t=CMD()", "'\t=CMD()"},
		{"normal text", "normal text"},
		{"$12.34", "$12.34"},
		{"", ""},
	}
	for _, c := range cases {
		if got := SanitizeCell(c.in); got != c.want {
			t.Fatalf("SanitizeCell(%q)=%q, want %q", c.in, got, c.want)
		}
	}
}

Where to wire it

In your analysis pipeline where you currently compute RawUSD (or call your existing ExtractUngradedUSD), swap to:

raw, src, note := analysis.ChooseRawUSD(card, analysis.SanitizeOptions{
    MinRawUSD:    minRawFlagValue,   // e.g. from --min-raw-usd (default 0.50)
    AllowPennies: allowPenniesFlag,  // usually false
    Rarity:       card.Rarity,
})
if raw <= 0 {
    // skip: nothing reasonable
    continue
}


If you support a --why flag, include src and note in the per-row explanation.

Before writing any text cells to CSV (titles, notes, URLs), pass them through report.SanitizeCell.

Run tests
go test ./... -race